# :pushpin: Spring Webflux + LLM 실전 구현

## :seedling: Spring WebFlux란?
- 저희가 WebFlux를 사용하고 싶다는건 리액티브한 서비스를 만들고 싶다고 말하는 것과 같습니다.
- WebFlux는 리액티브한 서비스를 쉽게 개발할 수 있도록 도와주는 스프링 프레임워크 라이브러리 입니다.
- 리액티브 서비스에서는 비동기 웹 서버의 활용이 중요한데, Webflux는 Netty와 같은 비동기 웹 서버와 스프링 애플리케이션을 자연스럽게 통합할 수 있도록 지원합니다.
- 이 외에도 스트림 방식의 데이터 처리, 논 블로킹 API 제공 등 다양한 리액티브 기능들을 포함하고 있습니다.

### 리액티브한 서비스란?
- '리액티브하다'는 것은 **요청에 빠르고 효율적으로 반응한다**라는 의미입니다.
- 사용자의 요청이 들어왔을 때 자원을 효율적으로 활용하여 신속하게 처리하고, 즉각 즉각 반응하는 서비스
- 이렇게 '리액티브'하게 만들기 위해서는 **비동기 웹 서버**의 활용이 필수적

### 왜 리액티브한 서비스에 비동기 웹 서버가 필수일까?
여기 치킨을 시키고 기다리는 두 사람이 있습니다.
두 사람은 각각 Tomcat이라는 방과 Netty라는 방에 들어가 있습니다.

#### 동기 블로킹 방식 (Tomcat이라는 방의 사람)
- 이 사람은 치킨이 도착할 때까지 아무것도 하지 않고 문 앞에서 기다립니다.
- 이 사람은 치킨을 시켰으면 치킨이 올 때까지 문 앞에서 기다리고 치킨과 동기적(Synchronous)으로 동작합니다.
- 여기서 아무것도 하지 않고 방문 앞에서 기다리고 있는 상황을 블로킹이라고 합니다. (치킨이 올때까지 블로킹)

#### 비동기 논블로킹 방식 (Netty라는 방의 사람)
- 이 사람은 치킨이 도착할 때까지 TV도 보고 문자도 보냅니다.
- 이 사람은 치킨을 시킨 후에 치킨이 오는걸 기다리지 않고 치킨과 비동기적(Asynchronous)으로 동작합니다.
  - 기존 스프링이 Tomcat/Servlet과 완벽히 통합되는 것처럼 Webflux는 Netty와 완벽한 통합을 지원한다.
  - WebClient, R2DBC 등 다양한 비동기 API와 쉽게 연동 가능
  - Publisher-Subscriber 패턴 (리액티브 스트림즈 구현체 - Flux Mono)을 기반으로 Netty의 이벤트 루프 패턴과 자연스럽게 통합
  - Stream 통신을 통해 결과물이 부분적으로 완성될 떄마다 사용자에게 즉시 전달 가능

#### 스레드란?
- 하나의 작업 흐름을 실행시켜 주는 것

#### Tomcat

![](./images/tomcat.png)

- 톰켓의 스레드는 IO(블로킹) 작업을 직접 대기하며 작업을 하나하나 차례대로 실행한다.
- 톰켓은 하나의 요청을 하나의 스레드가 처리한다.

#### Netty
![](./images/netty.png)

- 이벤트 루프: 스레드는 이벤트를 처리하고 이벤트 루프로 돌아와 다른 이벤트가 있는지 확인한다.
- Netty의 스레드는 한 개의 요청을 처리하고 작업을 끝내는게 아니라 이벤트 루프에서 이벤트를 끝없이 처리한다.

1. 우리 코드를 포함한 애플리케이션의 작업 흐름을 실행시켜주는 것이 스레드이다.
2. Netty는 적은 수의 스레드만을 사용하기 때문에 블로킹에 매우 취약하다.

#### 스레드 동작 방식

![](./images/thread.png)

```text
1. 우리 프로세스(웹 서버)에서 스레드를 원하는 만큼 생성하고 마음대로 이용할 수 있다. 
(이 스레드는 OS가 알아서 스케쥴링 해주기 때문에 CPU 자원 분배를 신경 쓸 필요가 없다)

2. 스레드를 너무 많이 생성하면 컨텍스트 스위칭 비용 등이 발생하기 때문에 Netty는 물리적인 스레드와 같은 개수의 스레드만을 사용한다.
```
